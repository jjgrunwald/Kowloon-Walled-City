<!DOCTYPE html>
<html lang="en">
<head>
  <title>Walled City - by JJ Grunwald</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum=scale=1.0">
  <link type="text/css" rel="stylesheet" href="data/main.css">
  <style>
    /* Fade-in effect CSS */
    body {
      margin: 0;
      padding: 0;
      background-color: #AAAAAA; /* Same gray color as the scene background */
      opacity: 0;
      transition: opacity 3s ease-in-out; /* Adjust duration to control the speed */
    }

    body.fade-in {
      opacity: 1;
    }
  </style>
</head>
<body>
  <div id="info">Walled City</div>
  <div id="details">A dynamically generated cityscape toy. Use your screen (mobile) or mouse (desktop) to explore. Created by J.J. Grunwald.</div>
  <div id="regenerateButtonContainer">
    <button id="regenerateButton" onclick="location.reload();">REGENERATE CITY</button>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "./build/three.module.js",
        "three/addons/": "./data/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from './build/three.module.js';
    import { OrbitControls } from './data/jsm/controls/OrbitControls.js';
    import { GLTFLoader } from './data/jsm/loaders/GLTFLoader.js';

    class KowloonWalledCity {
      constructor() {
        this._Initialize();
      }

      _Initialize() {
        this._threejs = new THREE.WebGLRenderer({
          antialias: true,
        });
        this._threejs.shadowMap.enabled = true;
        this._threejs.shadowMap.type = THREE.PCFSoftShadowMap;
        this._threejs.setPixelRatio(window.devicePixelRatio * 2); 
        this._threejs.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(this._threejs.domElement);

        window.addEventListener('resize', () => {
          this._OnWindowResize();
        }, false);

        const fov = 60;
        const aspect = window.innerWidth / window.innerHeight;
        const near = .01;
        const far = 1000.0;
        this._camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
        this._camera.position.set(154.17, 178.53, 134.24);

        this._scene = new THREE.Scene();

        let light = new THREE.DirectionalLight(0xFFFFFF, 4.0);
        light.position.set(90, 80, 15);
        light.target.position.set(0, 0, 0);
        light.castShadow = true;
        light.shadow.mapSize.width = 4096;
        light.shadow.mapSize.height = 4096;
        light.shadow.bias = -0.0001;
        light.shadow.camera.far = 500.0;
        light.shadow.camera.left = 100;
        light.shadow.camera.right = -100;
        light.intensity = 3.9;
        this._scene.add(light);
        this._scene.fog = new THREE.Fog(0xaaaaaa, 5, 500);

        this._threejs.toneMapping = THREE.ReinhardToneMapping;
        this._threejs.toneMappingExposure = 1;  
        this._threejs.gammaFactor = 12;
        
        light = new THREE.AmbientLight(0x101010);
        this._scene.add(light);

        const backColor = new THREE.Color(0xAAAAAA);
        this._scene.background = backColor;

        this._controls = new OrbitControls(this._camera, this._threejs.domElement);
        this._controls.target.set(90, 180, 0);
        this._controls.update();

        const loader = new GLTFLoader();

        // Array of apartment models
        const apartmentModels = [
            './data/models/apartment_001.glb',
            './data/models/apartment_002.glb',

            // Add more models as needed
        ];

        const rows = 28;
        const cols = 24;
        const xSpacing = 27;
        const ySpacing = 13.5;
        const xOffset = -320;

        for (let i = 0; i < rows; i++) {
            for (let j = 0; j < cols; j++) {
                const selectedApartment = apartmentModels[Math.floor(Math.random() * apartmentModels.length)];

                loader.load(selectedApartment, (gltf) => {
                    const model = gltf.scene;
                    model.scale.set(1.5, 1.5, 1.5);

                    const materials = [
                        new THREE.MeshStandardMaterial({ color: 0xb87948 })  // Rusty orange
                    ];

                    const randomMaterial = materials[Math.floor(Math.random() * materials.length)];
                    model.traverse((child) => {
                        if (child.isMesh) {
                            if (child.name === 'Window_Frame_Left' || child.name === 'Window_Frame_Right') {
                                child.material = randomMaterial;
                            }
                        }
                    });

                    model.position.set(j * xSpacing + xOffset, i * ySpacing, 0);
                    this._scene.add(model);

                    this._AddRandomPatio(model, loader);
                    this._AddRandomLaundry(model, loader);
                    this._AddRandomSign(model, loader);
                }, undefined, (error) => {
                    console.error('An error occurred while loading the apartment models:', error);
                });
            }
        }

        this.cameraRadius = 100;
        this.cameraAngle = 0;
        this.isRotating = false;

        this._RAF();
      }

      _AddRandomPatio(apartment, loader) {
        const patioModels = [
          './data/models/patio_001.glb',
          './data/models/patio_002.glb',
          './data/models/patio_003.glb',
          './data/models/patio_004.glb',
          null  // No patio option
        ];

        const selectedPatio = patioModels[Math.floor(Math.random() * patioModels.length)];

        if (selectedPatio) {
          loader.load(selectedPatio, (gltf) => {
            const patio = gltf.scene;
            patio.scale.set(1, 1, 1);

            const materials = [
              new THREE.MeshStandardMaterial({ color: 0x7bc1d6 }), // Light Blue
              new THREE.MeshStandardMaterial({ color: 0x8e7a7c }), // Light Tan
              new THREE.MeshStandardMaterial({ color: 0x317a50 })  // Dark Green
            ];
            const randomMaterial = materials[Math.floor(Math.random() * materials.length)];

            patio.traverse((child) => {
              if (child.isMesh) {
                child.material = randomMaterial;
                child.geometry.computeVertexNormals();
                child.material.side = THREE.DoubleSide;
              }
            });

            patio.position.set(0, 0, 0); 
            apartment.add(patio);
          }, undefined, (error) => {
            console.error('An error occurred while loading the patio models:', error);
          });
        }
      }

      _AddRandomLaundry(apartment, loader) {

        const shouldAddLaundry = Math.random() < 0.5;

        if (!shouldAddLaundry) {
          return; // Do not add laundry
        }

        const laundryModels = [
          './data/models/laundry_001.glb',
          './data/models/laundry_002.glb'  //Don't forget to add second model later.
        ];
        const selectedModel = laundryModels[Math.floor(Math.random() * laundryModels.length)];

        loader.load(selectedModel, (gltf) => {
          const laundry = gltf.scene;
          laundry.scale.set(1, 1, 1);

          const offsetX = 0; 
          const offsetY = -1;
          const offsetZ = 1.2;

          laundry.traverse((child) => {
            if (child.isMesh && child.name.startsWith('hanging')) {
              child.material = new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff });
              child.geometry.computeVertexNormals();
              child.material.side = THREE.DoubleSide;
            }
          });

          laundry.position.set(offsetX, offsetY, offsetZ); 
          apartment.add(laundry);

        }, undefined, (error) => {
          console.error('An error occurred while loading the laundry models:', error);
        });
      }

      _AddRandomSign(apartment, loader) {
        const shouldAddSign = Math.random() < 0.4;

        if (!shouldAddSign) {
          return; 
        }

        const signModels = [
          './data/models/sign_001.glb',
          './data/models/sign_002.glb',
          './data/models/sign_003.glb',
        ];

        const selectedSign = signModels[Math.floor(Math.random() * signModels.length)];

        loader.load(selectedSign, (gltf) => {
          const sign = gltf.scene;
          sign.scale.set(0.6, 0.6, 0.6);

          const offsetX = 0;
          const offsetY = 3; 
          const offsetZ = 1.5;

          sign.traverse((child) => {
            if (child.isMesh) {
              child.geometry.computeVertexNormals();
              child.material.side = THREE.DoubleSide;
            }
          });

          sign.position.set(offsetX, offsetY, offsetZ); 
          apartment.add(sign);

        }, undefined, (error) => {
          console.error('An error occurred while loading the sign models:', error);
        });
      }

      _OnWindowResize() {
        this._camera.aspect = window.innerWidth / window.innerHeight;
        this._camera.updateProjectionMatrix();
        this._threejs.setSize(window.innerWidth, window.innerHeight);
      }

      _RAF() {
        requestAnimationFrame(() => {
          this._RAF();
        });

        this._threejs.render(this._scene, this._camera);

        if (this.isRotating) {
          this.cameraAngle += 0.002;
          this._camera.position.x = Math.sin(this.cameraAngle) * this.cameraRadius;
          this._camera.position.z = Math.cos(this.cameraAngle) * this.cameraRadius;
          this._camera.lookAt(this._scene.position);
        }
      }
    }

    window.addEventListener('DOMContentLoaded', () => {
      document.body.classList.add('fade-in');
      _APP = new KowloonWalledCity(); // Initialize your scene here
    });
  </script>
</body>
</html>
